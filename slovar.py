# 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
a = [0, 1]
F = 1 # Ну, или как там. (Если что - можно не придумывать переменную F, а просто в условии поставить нужное число)
for x in a:  # Или можно брать "for x in range(2):"
    for y in a: # З.Ы. Задаем область значений для каждой буквы
        for z in a:
            for w in a:
                if (((x<=y) == (z <= w)) or ( x and w))==F:
                    print(z,y,x,w)  # тут просто меняем переменные местами

# 5 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# наименьшее число, больше 77 ...
for i in range(1, 1000): # Пусть программа ищет
    n = str(bin(i))[2:]  # Перевод в двоичку(.. При желании можно вместо "[2:]" можно вставить ".removeprefix('0b')..)
    if n.count('1')%2==0: # Условие из условия
        n += '0'
    else:
        n += '1'
    if n.count('1') % 2 == 0: # Тут было условие повторения дважды
        n += '0'
    else:
        n += '1'
    if int(n, 2) > 77:
        print(i, n)
        break
# Ещё вариант (Лишних вопросов лучше не задавать)
for x in range(10000, 100000):
    s1 = sum(map(int, str(x)[::2]))
    s2 = sum(map(int, str(x)[1::2]))
    if s1 > s2:
        res = str(s2) + str(s1)
    else:
        res = str(s1) + str(s2)
    if res == '723':
        print(x)
        break

# 6 - если "int(input()) - то просто перебор(Или если не лень, то можно придумать счётчик(А мне лень))\
# , в других случаях подстановка
# Буду честен - её в падлу делать по особенному. Там ctrl+c -> ctrl+v

# 8 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# обычный вариант
cnt = 0
srt = 'QWERTY'  # строка(чтобы не мучаться)
for a in srt:       # циклы для всего что есть(Жаль нельзя зациклировать процессы жизни чтобы жить вcегда)
    for b in srt:
        for c in srt:
            for d in srt:
                word = a+b+c+d
                if word.count('Q')==1:      #условие
                    cnt += 1   # счетчик
                    print(word)
# Не знаю к чему это
from itertools import*
s = set()
for x in permutations(range(16), r = 5):
    if x[0] != 0 and len(set(x))==5\
            and all((a + b)%2==1 for a,b in zip(x, x[16])):
                s.add(x)
                print(len(s))

# Если у нас идет только перестановка (через первый алгоритм тоже можно(Просто там муторно))
# Don't ask any questions. If it works - do not touch...
from itertools import* # Библиотека для работы с особыми функциями
words = set([x for x in permutations('KABALA', r = 6) # (ENG) permutations - перестановка
             if 'AA' not in ''.join(x)])
print(len(words))
#
from itertools import*
cnt = 0
for i in product('0123456', repeat = 5): # Задаем много повторений без лишних строк с помощью "product" и "repeat"
    s = i.join() # При построении слова эта команда ставит символы вплотную
    cnt += 1
    print(cnt)
# 12 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
srt = '9'*1000
while ('999' in srt) or ('888' in srt): # Ищет в "srt" нужные значения
    if '888' in srt:
        srt = srt.replace('888', '9', 1) # Заменяет одно на другое
    else:
        srt = srt.replace('999', '8', 1)    # Тут быть осторожным, потому что комп любит давать в конце 8998, а не 8899
print(srt)
#
# Влюбился с первого взгляда
s = 86*'8'
while ('1111' in s) or ('8888' in s):
    s = s.replace('1111', '8',1).replace('8888', '11', 1) # Без стороннего мусора эта тема тоже работает
    print(s)
# 13 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ПОЧТИ РАБОТАЕТ
# Странная штука...
s = 'АБВГД БЕВ ВЖЗ ГВЭ ДГЗ ЕЖИ ЖИ ЗЖИ ИКЛЛ КМ ЛМ М'
d = {w[0:]: w[1:] for w in s.split()}
def f(a, b):
    return 1 if a == b else\
        sum(f(c,b) for c in d[a])
print(f('А', 'В')* ('В' , 'М'))
# Ручкаи лучше...
# 14 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Количество единиц при делении на 2
# Аналошично можно сделать и с другими числами
srt = (4**2020) + (2**2017) - 15
cnt = 0
while srt > 0: # Чтобы всё работало само
    if srt%2 == 1:
        cnt += 1
    srt = srt // 2
print(cnt)
# Алгоритм подбора чисел, которые стали другими при переходе из десятичной системы
d = int(input()) # Предположительное основание
s = 18 # Известное нам число в 10-ной системе
while s > 1:
    print(s%d) # Ответ читать с конца!
    s = s // d
# 15 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Одна из самых нормальных и оптимизированных
def f(): # Можно вместо функции использовать переменную, но с ней больше опасности
    for x in range(1, 1001):
        for y in range(1, 1000):
            if( (2*x + 3*y < a) or (x >= y) or (y > 24) )==0: # Главное чтобы функция противоречила нужным значениям - иначе ничего не получится
                return 0
    return 1
for a in range(1, 1000):
    if f()==1:
        print(a)
# -_-_-
# Для какого наибольшего "а"...
def F(x, y, a): # Создаем функцию, которая проверяет условие из условия
    return (2*x +3*y < 30) or (x+y >= a)
for a in range(1, 1000): #Значения a (больше - лучше)
    if all(F(x,y,a)==1 for x in range(1,1000) for y in range(1,1000)):
        print(a)
#
def d(y,u): # Функция ДЕЛ
    if y%u==0: # Та самая проверка на делимость
        return 1
    else:
        return 0
for a in range(1, 1000):
    c = 0 # Не знаю почему, но без счетчика нельзя
    for x in range(1, 1001): # А тут нельзя без "x == 1001"
        if ( (d(x,3)) <= (not(d(x,5))) or (x+a>=70) )==1:
            c += 1
        if c == 1000: # Условие, при котором нам должно выводить "a"(т.к. всего значений очень много)
            print(a)
# 9804
# Минимальное число из такой-то функции
f = 1 # немножко сымитируем функцию
for a in range(1, 100): # Перебор всех значений
    f = 1 # Программа должна понимать, что "f" должна в ней присутствовать, поэтому записываем её опять
    for x in range(100):
        if( (x & 29 != 0) <= ((x & 17 == 0) <= (x & a != 0)) )==0: # Лучше начинать от обратного, то есть от проигрышной ситуации
            f = 0
    if f == 1: # А тут уже выполняется нужное нам условие
        print(a)

# 7763
# Наибольшая возможная длина A в таком-то промежутке
p = [i for i in range(5,30+1)] # Задаем значение P и Q. Создается список (P)
# [5,6,7,...,28,29,30]
q = [i for i in range(14, 23+1)]
mx = 0
for amin in range(1, 100): # Задаем минимум и максимум для A
    for amax in range(amin+1, 100):
        F = 1 # Не знаю как, но через True/False оно работает
        a = [i for i in range(amin, amax)]
        for x in range(1, 100):
            if ( ((x in p) == (x in q)) <= (not(x in a)) )==0: # Основная функция(логично).
                # Но сначала мы приравниваем к нулю
                F = 0
                break
        if F == 1: # Функция должна стать правильной
            mx = max(mx, len(a)) # Вытаскиваем максимальное количество подходящих чисел
            print(mx)
# З.Ы. Эта штука может косячить, поэтому проверяйте P и Q ещё без "+1"

# 16 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Последовательность цифр для алгоритма...
def f(n):
    if n > 0:
        f(n//4)
        print(n)
        f(n-1)  # Ничего такого тут нет

# 17 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Мы используем "i+1" когда в условии сказано, что пара - идущие подряд цифры
# Добавляем "j" уже в случае когда пара - случайные цифры
s = open('17.txt') # Пусть почитает - компу знания не помешают
n = [] # Пустой список, куда будем вносить все значения "s"
for a in s:
    n.append(int(a))  # Превращаем все значения из файла в список
cnt = 0 # logichno
mx = 0 # da
for i in range(len(n)-1):    # Размеры списка   # Но лучше всего тут использовать не i, но ещё и j
    # for j in range(i+1, len(n)):
    if n[i]%150==0 or n[i+1]%150==0: # Условия
        if n[i]%7==0 or n[i+1]%150==0:
            cnt += 1
            mx = max(mx, n[i] + n[i+1]) # Максималка будет обновляться при возможности
            print(cnt, mx)
# !
a = open('17.txt')
n = []
for s in a:
    n.append(int(s))
cnt = 0
mx = 0
for i in range(len(n)-1):
    for j in range(i + 1, len(n)):
        if (n[i]%160!=n[j]%160) and (n[i]%7==0 or n[j]%7==0):
            cnt += 1
            mx = max(mx, n[i]+n[j])
            print(cnt, mx)
# Найдите количество чисел которые меньше максимального числа, делящегося на 111, хотя бы одно из которых делится на 7
srt = open('17.txt')
n = []
nmax = cnt = 0
cntmin = float('inf')
for a in srt:
    n.append(int(a)) # Классика
for g in range(len(n)): # Задаем ещё один список значений. откуда выковыриваем максимальное
    if n[g]%111==0:
        nmax = max(nmax, n[g]) # Собственно, оно самое
for i in range(len(n)-1):
    if (n[i]>nmax) or (n[i+1]>nmax):
        if (n[i]%10==7) or (n[i+1]%10==7):
            cnt += 1
            cntmin = min(cntmin, n[i]+n[i+1])
            print(cnt, cntmin)
# 19, 20, 21 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
def G(F,W): return { s for s in z\
                     if F(t in W for t in(s+1, s+4, s*5))} # если правильно понимаю - тут мы задаем действия над кучей
z = {*range(1,62)} # Что-то откуда-то
w1 = G(any, range(62, 400)); z -= w1 # Ваня 1
l1 = G(all, w1); z -= l1 # Петя 1
w2 = G(any, l1)
l2 = G(all, w1 | w2)

print(*l1)
print(*sorted(w2))
print(*l2)

def C(F,W):
    return{ s for s in z
            if C(t in W for t in(s+1, s+3, s*2))}
z = {*range(1,42)}
w1 = C(any, range(42, 400)); z -= w1
l1 = C(all, w1); z -= l1
print(l1)

# 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# наибольшее число прикотором м=3 и л=6
'''
код с сайта
x = int(input())
L = 0
M = 0
while x > 0 :
    L = L+1
    if (x % 2) != 0:
        M = M + x % 8
    x = x // 8 
print(L) 
print(M)'''
# переделка
for x1 in range(1000):  # Предположительные значения для "х"
    x = x1 # Чтобы проверяло условия
    l = 0
    m = 0
    while x>0:
        l = l+1
        if (x%2)!= 0:
            m = m + x%8
        x = x//8
    if m == 3 and l == 6:  # Условие из дано(Обязательно на одном уровне с while)
        print(x1)

# 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

def f(x, n):
    if x > n: # Начальное число не может быть больше конечного
        return 0
    if x == n: # Если есть путь, приводящий "x" к "n", то все хорошо и он добавляет к невидимому списку 1
        return 1
    return( f(x+1, n) + f(x+2, n) + f(x*2, n)) # Все команды
print(f(3, 10)*f(10, 12)) # Умножаем, потому что "10->12" - это продолжение пути "3->10"

# 15117. Тут у нас есть условие, запрещающее использовать число 15
def F(x, n):
    if x > n:
        return 0
    if x == 15: # "x" не может быть равен тому, чему не хочет быть равен
        return 0
    if x == n:
        return 1
    return(F(x+1, n) + F(x+2, n))
print(F(3, 9)*F(9,20))

# 24 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 27421
srt = open('24_demo.txt')
n = srt.readline() # !!!"READLINE" ЧИТАЕТ ВЕСЬ ФАЙЛ КАК ОДНУ СТРОКУ, А "READLINES" ЧИТАЕТ ДОКУМЕНТ ПОСТРОЧНО
cnt = 1 # Поэтому нам тут нужен именно "readline"
mx = 1
for i in range(len(n)-1): # область значений перебора
    if n[i] != n[i-1]: # По условию буквы не должны совпадать, поэтому у нас также
        cnt += 1 # Счетчик
        mx = max(mx, cnt) # Вытаскиваем максимальное количество подряд идущих букв в отдельную переменную
    else:
        cnt = 1 # Обнуляем счетчик до единицы(буквы никуда не уходили, а порядок произвольный)
    print(mx)
#
# Последовательность из символов "Y"
cnt = mx = 1
s = open('24_demo.txt').readline()
for i in range(len(s)):
    if s[i]=='Y' and s[i+1]=='Y':
        cnt += 1
    else:
        cnt = 1
    mx = max(mx, cnt)
    print(mx, cnt)
# 27689
srt = open('24_demo.txt')
n = srt.readline()
cnt = 0
mx = 0
i = n.find('XYZ') # Программа ищет в файле комбинацию "XYZ"
while i < len(n): # Количество наших символов не может быть больше файла,\
    # поэтому перебираем всё по очереди("for" тут не подходит(почему - я не знаю))
    if n[i:i+3] == 'XYZ': # Список содержит это -> всё хорошо
        cnt += 3
        i += 2 # При нахождении нужных значений, программа перебирает всё дальше
    elif cnt: # Если нашлось "XYZ" - все работает дальше
        if n[i:i+2]=='XY':
            cnt += 2
            i += 1
        elif n[i] == 'X':
            cnt += 1
        mx = max(cnt, mx)
        cnt = 0
    i += 1
    print(mx)
#36037
# Сам не знаю как это работает
# Последовательность из "XZZY"
srt = open('24.txt') # open file
n = srt.read().replace('XZZY', 'AAA AAA').split() # Проводим замену и раздел букв
print(len(max(n, key=len))) # Ищем максимальную длину нужной цепочки

# Текстовый файл содержит строки различной длины. Строки = (ABCD...XYZ).\
# Определите количество строк, в которых буква E встречается чаще, чем буква A.
with open('inf_22_10_20_24.txt') as file:
    for n in file.readlines(): # Если я правильно понимаю, то он построчно все разбирает
        A = 0 # Записывает количество "А" в строке
        E = 0
        cnt = 0
        for i in n:
            if i == 'A': # Счётчик букв "А"
                A += 1
            if i == 'E': # Счетчик букв "Е"
                E += 1
        if n.count('E') > n.count('A'):
            cnt += 1 # выписывает удовлетворяющие строки
            print(cnt) # Потом через ctrl+f считаем количество строк
# Досрок 2022. Решил совершенно случайно -_:^_-
# Текстовый файл состоит из символов ABC. Определите максимальное количество идущих подряд пар символов AB или CB.
# Подпоследовательность должна состоять только из пар AB, или только пар CB в произвольном порядке следования этих пар.
srt = open('107_24.txt')
n = srt.readline()
cnt = 0
mx = 0
for i in range(len(n) - 1):
    if (n[i] == 'C' and n[i + 1] == 'B') or (n[i] == 'B' and n[i + 1] == 'C'):
    # To see another answer you have to change "C" on "A"
        cnt += 2 # We are adiing 2 because programm read all in couples
    else:
        cnt = 1
    mx = max(mx, cnt)
    print(cnt, '->', mx) #eeeeee boiiiii

# 25 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# :_:_:_:_:_: Лучшие варианты решений для РЕШУ ЕГЭ
# 27422
# Тут в условии написано: "Кроме единицы и числа. Делители от 2-х)
for n in range(174457, 173505+1): # Область определения чисел
    ds = []  # Список делителей(отступ обязателен, чтобы для каждого нового числа создавался свой список делителей)
    for d in range(2, n//2 + 1): # Делители из списка "s"
        if n % d == 0:  # Основное условие
            ds.append(d)
            if len(ds)>2: # Чтобы не перелетать
                break
    # Если что-то не так, то в этой строке нужно написать 'ds.append(s)' и будет шанс на жизнь
    if len(ds) == 2: # ДА
        print(ds)

# 27853. Как прошлое, но немного другое
for s in range(312614, 312651 + 1):
    ds = []
    for d in range(1, s//2 + 1): # В условии не сказано "кроме единицы", поэтому её тоже можно потыкать
        if s % d == 0:
            ds.append(d)
            if len(ds) > 6: break
    ds.append(s) # Так как у нас делители не больше s/2, то эта строчка добавляет нам еще один правильный делитель
    if len(ds) == 6:
        print(ds)

# 27850. Счетчик простых чисел
for s in range(245690, 245756+1):
    ds = []
    for d in range(2, s//2 + 1): # ПО любому отталкиваемся от 2-х, ибо на 1 и так делится всё
        if s % d == 0:
            ds.append(d)
            if len(ds)>0: # Если у чила есть делитель -> оно не подходит
                break
    if len(ds)==0: # А вот если у него нет делителей - то всё хорошо
        print(s, s-245690+1) # Тут "s - s(min)" как раз дает нам порядковый номер из существующего списка
# 37130
for srt in range(600000, 600100): # Logically, place of choosing
    for d in range(1, srt // 2 + 1):
        if d != 7 and d % 10 == 7: # Our main condition
            if srt % d == 0:
                print(srt, d) # We have to find first(and most little)
                break

# :_:_:_:_:_:_:_:

# Кажется 25 (Даже запустилось)
for n in range(126849,126871+1):
    divs = [] # чистим список делителей
    for d in range(1,n+1): #
        if n % d == 0:
            divs = divs + [d] # добавляем делитель в список
        if len(divs) > 4: break
    if len(divs) == 4:
        print(*divs)

# Сам не знаю откуда это и зачем, но оно работает
for srt in range(174457, 174505+1):
    dev = []
    for d in range(2, round(srt**0.5)+2):
        if srt % d == 0:
            dev.append(d)
            dev.append(srt//d)
        if len(set(dev)) > 2: break
    if len(set(dev))==2:
        print(*dev)


        
# !_!_!_!_!_!_!_!_!_!_!_!
# Когда-нибудь что-нибудь тут может появиться
# КоГдА-НиБуДь,.,.,.,.,.,.,.,.,.,.,.,.,.,.,.,